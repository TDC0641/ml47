<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ML47 テスト（緑表示・hi4）</title>
<style>
  html,body{ margin:0; background:#fff; font-family:system-ui,-apple-system,"Noto Sans JP",sans-serif; }
  #mapWrap{ min-height:70vh; display:flex; align-items:center; justify-content:center; padding:12px; margin:12px; background:#fff; }
  svg{ width:100%; height:auto; display:block; background:#fff; }
  .hoverable{ cursor:pointer; }
</style>
</head>
<body>
  <div id="mapWrap">地図を読み込み中…</div>

<script>
(async () => {
  const wrap = document.getElementById('mapWrap');
  const NS   = 'http://www.w3.org/2000/svg';
  const TAGS = new Set(['path','polygon','polyline','rect','circle','ellipse','use']);

  try {
    // map.svg取得（キャッシュ回避）
    const res = await fetch('./map.svg?v=' + Date.now(), { cache:'no-store' });
    if (!res.ok) throw new Error(res.status + ' ' + res.statusText);
    const svgText = await res.text();

    // 厳密パース & text/tspan除去
    const doc = new DOMParser().parseFromString(svgText, 'image/svg+xml');
    doc.querySelectorAll('text,tspan').forEach(n=>n.remove());

    let svg = doc.querySelector('svg');
    if (!svg) throw new Error('SVG root not found');
    svg = document.importNode(svg, true);
    wrap.innerHTML = '';
    wrap.appendChild(svg);

    // util
    const qAll = (root)=>Array.from(root.querySelectorAll('*'));
    const isDrawable = (el)=>TAGS.has(el.localName);
    const nearestNode = (el)=>el.closest('g') || el;

    // <use>参照を展開し、x/y/transformはクローンに自然継承されるよう「同じ親」に重ねる
    function collectShapes(node){
      if (isDrawable(node)) return [node];
      const arr = qAll(node).filter(isDrawable);
      return arr.length ? arr : [];
    }

    // クリックで“同じ親”にクローンを最後に追加＝座標系ずれなしで最上面へ
    function addSiblingHighlight(node){
      const parent = node.parentNode;
      if (!parent) return;

      // 既存ハイライトを消す（この親直下のみ）
      Array.from(parent.children).forEach(ch=>{
        if (ch.nodeType===1 && ch.getAttribute('data-ml47-hi')==='1') ch.remove();
      });

      // ハイライト用のラッパー（この親の座標系をそのまま使う）
      const wrapG = document.createElementNS(NS,'g');
      wrapG.setAttribute('data-ml47-hi','1');
      wrapG.style.pointerEvents = 'none';

      // gなら内部図形、単体図形ならそれ自身をクローン
      const targets = collectShapes(node);
      if (targets.length === 0) {
        // フォールバック：BBox矩形
        try {
          const bb = (node.getBBox ? node.getBBox() : parent.getBBox());
          const rect = document.createElementNS(NS,'rect');
          rect.setAttribute('x', bb.x); rect.setAttribute('y', bb.y);
          rect.setAttribute('width', bb.width); rect.setAttribute('height', bb.height);
          rect.style.fill = '#2ecc71'; rect.style.fillOpacity = '0.35';
          rect.style.stroke = '#2ecc71'; rect.style.strokeWidth = '4';
          rect.style.pointerEvents = 'none';
          wrapG.appendChild(rect);
        } catch(_){}
      } else {
        targets.forEach(src=>{
          const copy = src.cloneNode(true);
          // 目に見えるよう不要な制約は除去
          copy.removeAttribute('clip-path');
          copy.removeAttribute('mask');
          copy.removeAttribute('filter');
          // ID衝突回避
          copy.removeAttribute('id');
          // 強制スタイル（!important）
          copy.style.setProperty('pointer-events','none','important');
          copy.style.setProperty('fill','#2ecc71','important');
          copy.style.setProperty('fill-opacity','0.35','important');
          copy.style.setProperty('stroke','#2ecc71','important');
          copy.style.setProperty('stroke-width','4','important');
          // 可能なら非スケーリング線
          copy.style.setProperty('vector-effect','non-scaling-stroke','important');
          wrapG.appendChild(copy);
        });
      }
      parent.appendChild(wrapG); // 同じ親の末尾＝最上面
    }

    // クリック付与
    const drawables = qAll(svg).filter(isDrawable);
    drawables.forEach(el=>{
      el.style.pointerEvents = 'all';
      el.classList.add('hoverable');
      el.addEventListener('click',(ev)=>{
        ev.stopPropagation();
        const node = nearestNode(el);
        const pref = node.querySelector('title')?.textContent?.trim()
                   || node.getAttribute('data-pref')
                   || node.id?.replace(/^pref[-_]/,'')
                   || el.id || '（名称不明）';
        alert(`県: ${pref} にログ追加`);
        addSiblingHighlight(node);
      }, { passive:true });
    });
  } catch (e) {
    wrap.textContent = 'map.svgの読み込みに失敗: ' + e.message;
  }
})();
</script>
</body>
</html>
