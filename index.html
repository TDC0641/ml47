<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ML47 テスト（緑表示・簡易版）</title>
<style>
  html,body{ margin:0; background:#fff; font-family:system-ui,-apple-system,"Noto Sans JP",sans-serif; }
  #mapWrap{ min-height:70vh; display:flex; align-items:center; justify-content:center; padding:12px; margin:12px; background:#fff; }
  svg{ width:100%; height:auto; display:block; background:#fff; }
  .hoverable{ cursor:pointer; }
</style>
</head>
<body>
  <div id="mapWrap">地図を読み込み中…</div>

<script>
(async () => {
  const wrap = document.getElementById('mapWrap');
  const NS   = 'http://www.w3.org/2000/svg';
  const TAGS = new Set(['path','polygon','polyline','rect','circle','ellipse','use']);

  try {
    // map.svgを取得（キャッシュ回避）
    const res = await fetch('./map.svg?v=' + Date.now(), { cache:'no-store' });
    if (!res.ok) throw new Error(res.status + ' ' + res.statusText);
    const svgText = await res.text();

    // 厳密にパースし、text/tspanは除去
    const doc = new DOMParser().parseFromString(svgText, 'image/svg+xml');
    doc.querySelectorAll('text,tspan').forEach(n=>n.remove());

    let svg = doc.querySelector('svg');
    if (!svg) throw new Error('SVG root not found');
    svg = document.importNode(svg, true);
    wrap.innerHTML = '';
    wrap.appendChild(svg);

    // ハイライト最上面レイヤー
    const hi = document.createElementNS(NS,'g');
    hi.id = 'ml47-highlight';
    hi.style.pointerEvents = 'none';
    svg.appendChild(hi);

    // <use>参照を解決し、x/y/transformを継承
    function resolveUse(el){
      let base = el;
      let t = el.getAttribute('transform') || '';
      const x = el.getAttribute('x'), y = el.getAttribute('y');
      if ((x && x !== '0') || (y && y !== '0')) t += ` translate(${+x||0},${+y||0})`;
      if (el.localName === 'use') {
        const href = el.getAttribute('href') || el.getAttribute('xlink:href');
        if (href && href.startsWith('#')) {
          const ref = svg.querySelector(href);
          if (ref) base = ref;
        }
      }
      return { base, transform: t.trim() };
    }

    // gなら内側の図形、単体図形ならそれ自身を返す
    function collectShapes(node){
      if (TAGS.has(node.localName)) return [node];
      const arr = Array.from(node.querySelectorAll('*')).filter(n=>TAGS.has(n.localName));
      return arr.length ? arr : [];
    }

    // クリック対象を収集
    const drawables = Array.from(svg.querySelectorAll('*')).filter(el=>TAGS.has(el.localName));
    drawables.forEach(el=>{
      el.style.pointerEvents = 'all';
      el.classList.add('hoverable');

      el.addEventListener('click',(ev)=>{
        ev.stopPropagation();
        const node = el.closest('g') ?? el;

        // まずはポップアップ（県名は簡易：title→id）
        const pref = node.querySelector('title')?.textContent?.trim()
                  || node.id || '（名称不明）';
        alert(`県: ${pref} にログ追加`);

        // 既存ハイライトを消去
        while (hi.firstChild) hi.removeChild(hi.firstChild);

        // <use>やtransformを反映したラッパー
        const { base, transform } = resolveUse(node);
        const wrapG = document.createElementNS(NS,'g');
        wrapG.style.pointerEvents = 'none';
        if (transform) wrapG.setAttribute('transform', transform);

        // クローンを最上面に重ねて“確実に”緑表示
        const shapes = collectShapes(base);
        if (shapes.length) {
          shapes.forEach(src=>{
            // 個々の<use>も解決して表示
            let b = src, extraT = '';
            if (b.localName === 'use') {
              const r = resolveUse(b);
              b = r.base; extraT = r.transform;
            }
            const holder = document.createElementNS(NS,'g');
            if (extraT) holder.setAttribute('transform', extraT);

            const copy = b.cloneNode(true);
            copy.removeAttribute('clip-path');
            copy.removeAttribute('mask');
            copy.removeAttribute('filter');
            copy.style.pointerEvents = 'none';
            copy.setAttribute('fill','#2ecc71');
            copy.setAttribute('fill-opacity','0.35');
            copy.setAttribute('stroke','#2ecc71');
            copy.setAttribute('stroke-width','4');
            holder.appendChild(copy);
            wrapG.appendChild(holder);
          });
          hi.appendChild(wrapG);
        } else {
          // フォールバック：BBox矩形で可視化
          try {
            const bb = (node.getBBox ? node.getBBox() : base.getBBox());
            const rect = document.createElementNS(NS,'rect');
            rect.setAttribute('x', bb.x); rect.setAttribute('y', bb.y);
            rect.setAttribute('width', bb.width); rect.setAttribute('height', bb.height);
            rect.setAttribute('fill', '#2ecc71');
            rect.setAttribute('fill-opacity', '0.35');
            rect.setAttribute('stroke', '#2ecc71');
            rect.setAttribute('stroke-width', '4');
            if (transform) rect.setAttribute('transform', transform);
            hi.appendChild(rect);
          } catch(_) {}
        }
      }, { passive:true });
    });
  } catch (e) {
    wrap.textContent = 'map.svgの読み込みに失敗: ' + e.message;
  }
})();
</script>
</body>
</html>
